"use strict";(self.webpackChunkdatakit_docs=self.webpackChunkdatakit_docs||[]).push([[730],{7762:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var n=i(4848),l=i(8453);const s={},a="HtmlField",d={id:"Fields/html-field",title:"HtmlField",description:"The HtmlField is a really powerful field, as it renders any content given as pure HTML. Especially in combination",source:"@site/docs/Fields/15-html-field.md",sourceDirName:"Fields",slug:"/Fields/html-field",permalink:"/Fields/html-field",draft:!1,unlisted:!1,editUrl:"https://github.com/UseDataKit/SDK/edit/main/docs/Fields/15-html-field.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{},sidebar:"docs",previous:{title:"TextField",permalink:"/Fields/text-field"},next:{title:"DateTimeField",permalink:"/Fields/datetime-field"}},r={},c=[{value:"Security",id:"security",level:2},{value:"Applying field settings",id:"applying-field-settings",level:2},{value:"Custom field instead of using a callback",id:"custom-field-instead-of-using-a-callback",level:2}];function o(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"htmlfield",children:"HtmlField"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"HtmlField"})," is a really powerful field, as it renders any content given as pure HTML. Especially in combination\nwith a custom ",(0,n.jsx)(t.a,{href:"/Fields/using-fields#change-value-before-rendering",children:(0,n.jsx)(t.code,{children:"callback()"})})," method; there is little this field\ncannot do."]}),"\n",(0,n.jsx)(t.h2,{id:"security",children:"Security"}),"\n",(0,n.jsxs)(t.p,{children:["Allowing HTML on a field can be a security issue. Especially when the data you are providing is coming from users or\na third-party service. To shield you from certain of these issues; the ",(0,n.jsx)(t.code,{children:"HtmlField"})," will strip away all ",(0,n.jsx)(t.code,{children:"<script>"})," tags\nfrom the content, before adding it to the page."]}),"\n",(0,n.jsx)(t.h2,{id:"applying-field-settings",children:"Applying field settings"}),"\n",(0,n.jsxs)(t.p,{children:["While an ",(0,n.jsx)(t.code,{children:"HtmlField"})," is a real power house, it does come with some custom modifiers, on top of on top of\nthe ",(0,n.jsx)(t.a,{href:"/Fields/using-fields#applying-field-settings",children:"default modifiers"}),"."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"->allow_scripts()"})," Includes all ",(0,n.jsx)(t.code,{children:"<script>"})," tags and executes their content."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"->deny_scripts()"})," Removes all ",(0,n.jsx)(t.code,{children:"<scripts>"})," tags from the content (default)."]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-php",children:"use DataKit\\DataViews\\Field\\HtmlField;\n\nHtmlField::create( 'html', 'Html label' );\n"})}),"\n",(0,n.jsx)(t.h2,{id:"custom-field-instead-of-using-a-callback",children:"Custom field instead of using a callback"}),"\n",(0,n.jsxs)(t.p,{children:["While the ",(0,n.jsx)(t.code,{children:"callback()"})," method is really convenient to easily change certain formatting of your value, it can become\ncumbersome to add the same callback on multiple fields. Also, adding a callback can prevent fields from being\nserialized, which can be a requirement when storing the field configuration between requests (for example in a\ndatabase)."]}),"\n",(0,n.jsxs)(t.p,{children:["In these cases it might make more sense to create a custom field. While you cannot ",(0,n.jsx)(t.code,{children:"extend"})," the ",(0,n.jsx)(t.code,{children:"HtmlField"})," as it\nis ",(0,n.jsx)(t.code,{children:"final"}),", you can create a new field that defers the rendering to an ",(0,n.jsx)(t.code,{children:"HtmlField"}),". Here is an example of what it\nwould take to create a (fictive) ",(0,n.jsx)(t.code,{children:"MarkdownField"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-php",children:"use DataKit\\DataViews\\Field\\Field;\nuse DataKit\\DataViews\\Field\\HtmlField;\n\nfinal class MarkdownField extends Field {\n    // This is the field that will do the actual rendering.\n    private HtmlField $html;\n    \n    // Overwrite the constructor to instantiate the wrapped HtmlField.\n    protected function __construct( string $id,string $label ) {\n        parent::__construct( $id, $label );\n\n        $this->html = HtmlField::create( $id, $header )->allow_scripts();\n    }\n\n    // Overwrite to parse the markdown content and return it as HTML.    \n    public function get_value( array $data ) {\n        $markdown = parent::get_value( $data );\n\n        // Call a (fictive) MarkdownParser service to generate the HTML.\n        return MarkdownParser::parse( $markdown );\n    }\n    \n    // Overwrite render to call the `HtmlField::render()` method.\n    public function render(): string {\n        return isset( $this->html ) ? $this->html->render() : parent::render();\n    }\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>d});var n=i(6540);const l={},s=n.createContext(l);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);